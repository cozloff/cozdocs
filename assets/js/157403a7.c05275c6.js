"use strict";(self.webpackChunkcozdocs=self.webpackChunkcozdocs||[]).push([[7367],{1842:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/image-491dbe419220e5590277db7de5d8eab1.png"},7799:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"entra/graph-automation-optimize","title":"ASP.NET + Graph API - Fastest Entra Automation","description":"alt text","source":"@site/docs/entra/graph-automation-optimize.md","sourceDirName":"entra","slug":"/entra/graph-automation-optimize","permalink":"/cozdocs/docs/entra/graph-automation-optimize","draft":false,"unlisted":false,"editUrl":"https://github.com/cozloff/cozdocs/edit/main/docs/entra/graph-automation-optimize.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Entra","permalink":"/cozdocs/docs/category/entra"},"next":{"title":"Terraform","permalink":"/cozdocs/docs/category/terraform"}}');var t=s(4848),r=s(8453);const o={sidebar_position:6},a="ASP.NET + Graph API - Fastest Entra Automation",l={},c=[{value:"\ud83d\udea9 Challenge",id:"-challenge",level:2},{value:"\u26a1 Solution",id:"-solution",level:2},{value:"1. Hash Map for User \u2194 Role",id:"1-hash-map-for-user--role",level:3},{value:"2. Batch Processing to Avoid Throttling",id:"2-batch-processing-to-avoid-throttling",level:3},{value:"3. Safe Parallelization + Race Condition Fix",id:"3-safe-parallelization--race-condition-fix",level:3},{value:"\ud83c\udfc6 Results",id:"-results",level:2},{value:"\ud83d\udcda Key Takeaways",id:"-key-takeaways",level:2}];function d(e){const n={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"aspnet--graph-api---fastest-entra-automation",children:"ASP.NET + Graph API - Fastest Entra Automation"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"alt text",src:s(1842).A+"",width:"798",height:"585"})}),"\n",(0,t.jsxs)(n.p,{children:["This paper highlights how to significantly improve ",(0,t.jsx)(n.strong,{children:"Entra Graph API performance"})," by introducing an application layer built in ",(0,t.jsx)(n.strong,{children:"ASP.NET (C#)"}),", enabling ",(0,t.jsx)(n.strong,{children:"efficient automation of identity administration"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["It also demonstrates why ",(0,t.jsx)(n.strong,{children:"Entra automation belongs in a dedicated organizational microservice"}),", not scattered across scripts or siloed apps."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-challenge",children:"\ud83d\udea9 Challenge"}),"\n",(0,t.jsxs)(n.p,{children:["Microsoft Entra provides the identity backbone, but ",(0,t.jsx)(n.strong,{children:"raw Graph API calls are not enough"})," for enterprise-scale automation:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Redundancy & inefficiency"}),": Direct Graph calls often repeat the same expensive queries."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complex throttling rules"}),": API limits (e.g. 15 users per bulk request) make na\xefve implementations brittle."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Concurrency pitfalls"}),": Scripts or lightweight tools often break under multi-threaded workloads."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Policy enforcement"}),": Without a central layer, authorization logic is duplicated inconsistently across teams."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," build a reusable ",(0,t.jsx)(n.strong,{children:"application service"})," on top of Entra that abstracts these complexities, optimizes Graph access, and standardizes identity automation for the whole organization."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-solution",children:"\u26a1 Solution"}),"\n",(0,t.jsx)(n.p,{children:"Week 8/30/2025, I introduced three main improvements:"}),"\n",(0,t.jsx)(n.h3,{id:"1-hash-map-for-user--role",children:"1. Hash Map for User \u2194 Role"}),"\n",(0,t.jsxs)(n.p,{children:["Instead of fetching user objects repeatedly for each role group, I ",(0,t.jsx)(n.strong,{children:"parallelized group membership fetching"})," but stored results in a ",(0,t.jsx)(n.strong,{children:"dictionary"})," mapping ",(0,t.jsx)(n.code,{children:"UserId \u2192 Role"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"// Build dictionary UserId \u2192 Role (single role only)\nDictionary<string, string> roleMap = userRoles\n    .GroupBy(m => m.UserId)\n    .ToDictionary(\n        g => g.Key,\n        g => g.First().Role\n    );\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"2-batch-processing-to-avoid-throttling",children:"2. Batch Processing to Avoid Throttling"}),"\n",(0,t.jsxs)(n.p,{children:["The Graph API has a ",(0,t.jsx)(n.strong,{children:"hard 15-user batch limit"}),". To handle this, I processed user IDs in ",(0,t.jsx)(n.strong,{children:"chunks of 15"}),", calling the bulk endpoint only once per batch."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Process in batches of 15\nfor (int i = 0; i < userIds.Count; i += 15)\n{\n    List<string> batch = userIds.Skip(i).Take(15).ToList();\n\n    // Bulk fetch all users by IDs\n    string ids = string.Join(",", batch.Select(id => $"\'{id}\'"));\n    Result<UserCollectionResponse> usersResponse =\n        await _graphRepository.GetAllUsersInfo15Max(ids);\n\n    // ...\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"3-safe-parallelization--race-condition-fix",children:"3. Safe Parallelization + Race Condition Fix"}),"\n",(0,t.jsxs)(n.p,{children:["Users are projected ",(0,t.jsx)(n.strong,{children:"in parallel"})," while avoiding shared state mutation. Instead of threads colliding, each batch aggregates safely, and results are flattened only after completion:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"IEnumerable<Task<UserInfo>> tasks = usersResponse.Value.Value.Select(\n    async user =>\n    {\n        string role = roleMap.ContainsKey(user.Id) ? roleMap[user.Id] : string.Empty;\n        string roleValue = MapRole(role);\n\n        return new UserInfo\n        {\n            ...\n            Role = roleValue\n        };\n    });\n\nUserInfo[] results = await Task.WhenAll(tasks);\nallUsers.AddRange(results);\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-results",children:"\ud83c\udfc6 Results"}),"\n",(0,t.jsx)(n.admonition,{title:"Performance Gain",type:"tip",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"10 seconds for 5 users \u2192 a few milliseconds for 20 users."})})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stable concurrency"}),": Race condition eliminated when parallelizing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resilient against throttling"}),": Clean batch processing aligned with Graph\u2019s 15-user cap."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reusability"}),": Teams can now consume this identity microservice instead of re-implementing Graph logic."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-key-takeaways",children:"\ud83d\udcda Key Takeaways"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Build on Entra, don\u2019t just call it."}),(0,t.jsx)(n.br,{}),"\n","The ",(0,t.jsx)(n.strong,{children:"Graph API"})," is powerful but ",(0,t.jsx)(n.strong,{children:"low-level"})," \u2014 organizations need an ",(0,t.jsx)(n.strong,{children:"application layer microservice"})," to make it ",(0,t.jsx)(n.strong,{children:"consumable at scale"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:".NET is the best fit"})," for this layer: ",(0,t.jsx)(n.strong,{children:"type-safe"}),", ",(0,t.jsx)(n.strong,{children:"async-friendly"}),", and deeply integrated with ",(0,t.jsx)(n.strong,{children:"Microsoft identity"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimize once, reuse everywhere."}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Identity automation"})," should live in a ",(0,t.jsx)(n.strong,{children:"shared service"}),", not inside every app."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.admonition,{title:"Other Contributors",type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minh Phan"})," \u2014 Parallelization strategy idea. Key contributions to utilizing Entra for workforce and external users. And refactoring the multi-tenant Graph Clients."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Kupu Tuifua"})," \u2014 Typing & repository refactoring"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ian Manzano"})," \u2014 End-to-end testing the graph services"]}),"\n"]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);