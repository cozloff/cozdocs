"use strict";(self.webpackChunkcozdocs=self.webpackChunkcozdocs||[]).push([[6616],{4686:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/image-2-e8b9887ec072d31e348d8205d30b9276.png"},7109:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/image-1-ddeb6b86be5c211aaa2e469289d1984e.png"},7294:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"redis/redis-session-management","title":"MSAL Node + Redis \u2014 Token Cache & Session Management","description":"alt text","source":"@site/docs/redis/redis-session-management.md","sourceDirName":"redis","slug":"/redis/redis-session-management","permalink":"/cozdocs/docs/redis/redis-session-management","draft":false,"unlisted":false,"editUrl":"https://github.com/cozloff/cozdocs/edit/main/docs/redis/redis-session-management.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Redis","permalink":"/cozdocs/docs/category/redis"},"next":{"title":"Collaboration","permalink":"/cozdocs/docs/category/collaboration"}}');var t=s(4848),r=s(8453);const a={sidebar_position:8},o="MSAL Node + Redis \u2014 Token Cache & Session Management",c={},l=[{value:"\ud83d\udea9 Challenge",id:"-challenge",level:2},{value:"\u26a1 Solution",id:"-solution",level:2},{value:"1. Confidential Client with Certificate Auth",id:"1-confidential-client-with-certificate-auth",level:3},{value:"2. Redis Token Cache Plugin",id:"2-redis-token-cache-plugin",level:3},{value:"3. Smarter Refresh Strategy",id:"3-smarter-refresh-strategy",level:3},{value:"4. RedisInsight for Session Management &amp; Ops",id:"4-redisinsight-for-session-management--ops",level:3},{value:"\ud83c\udfc6 Results",id:"-results",level:2},{value:"\ud83d\udcda Key Takeaways",id:"-key-takeaways",level:2}];function d(e){const n={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"msal-node--redis--token-cache--session-management",children:"MSAL Node + Redis \u2014 Token Cache & Session Management"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"alt text",src:s(4686).A+"",width:"1263",height:"715"})}),"\n",(0,t.jsxs)(n.p,{children:["This paper highlights how I used ",(0,t.jsx)(n.strong,{children:"MSAL Node with certificate-based authentication"})," and an encrypted ",(0,t.jsx)(n.strong,{children:"Redis-backed token cache"})," to provide a secure, scalable, and reliable solution for ",(0,t.jsx)(n.strong,{children:"multi-tenant authentication and session management"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["It also demonstrates why ",(0,t.jsx)(n.strong,{children:"Redis caching for MSAL"})," is critical in a ",(0,t.jsx)(n.strong,{children:"distributed container apps environment"}),", enabling consistent user sessions across replicas."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-challenge",children:"\ud83d\udea9 Challenge"}),"\n",(0,t.jsx)(n.p,{children:"Authentication with Microsoft Entra can get complicated at scale:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tenant switching"}),": Different tenants require different authorities."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session persistence"}),": In a containerized environment, ephemeral pods lose session state without a shared cache."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Operations visibility"}),": Debugging live sessions across containers is nearly impossible without a centralized view."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," build a ",(0,t.jsx)(n.strong,{children:"Redis-backed token cache layer for MSAL"})," to unify session persistence, security, and visibility."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-solution",children:"\u26a1 Solution"}),"\n",(0,t.jsx)(n.p,{children:"Week 9/6/2025, I introduced the following improvements:"}),"\n",(0,t.jsx)(n.h3,{id:"1-confidential-client-with-certificate-auth",children:"1. Confidential Client with Certificate Auth"}),"\n",(0,t.jsxs)(n.p,{children:["I use a ",(0,t.jsx)(n.strong,{children:"singleton factory"})," to expose two ",(0,t.jsx)(n.strong,{children:"MSAL Node\u2019s ConfidentialClientApplication"})," with certificates pulled from ",(0,t.jsx)(n.strong,{children:"Azure Key Vault"}),", ensuring secure client credential flow to a Workforce tenant and a CIAM tenant."]}),"\n",(0,t.jsxs)(n.p,{children:["This is still ",(0,t.jsx)(n.strong,{children:"OIDC-compliant"})," (using OAuth2/OpenID Connect under the hood) \u2014 MSAL abstracts the complexity and handles silent refreshes, authority validation, and multi-tenant login."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"  const cca = new msal.ConfidentialClientApplication({\n    auth: {\n      clientId,\n      authority: tenantAuthority,\n      clientCertificate: { thumbprint, privateKey },\n      knownAuthorities: [new URL(tenantAuthority).hostname], // force trust for CIAM\n    },\n    cache: { cachePlugin: makeRedisCachePlugin(tenantKey) },\n    system: {\n        // [ Confidential ]\n      },\n    },\n  });\n\n  ccaInstances[tenantKey] = cca;\n  return cca;\n};\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"2-redis-token-cache-plugin",children:"2. Redis Token Cache Plugin"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"custom Redis cache plugin"})," stores access tokens (AT) and refresh tokens (RT).",(0,t.jsx)(n.br,{}),"\n","Each tenant has its own cache key (",(0,t.jsx)(n.code,{children:"msal-cache:tenantId"}),"), isolating tokens per tenant for security."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export const makeRedisCachePlugin = (tenantKey: string): ICachePlugin => ({\n  beforeCacheAccess: async (ctx) => {\n    const key = cacheKey(tenantKey);\n    const data = await redis.get(key); // Get by cache key\n    if (data) {\n      ctx.tokenCache.deserialize(data); // Deserialize the session\n    }\n  },\n  afterCacheAccess: async (ctx) => {\n    if (!ctx.cacheHasChanged) return;\n    const serialized = ctx.tokenCache.serialize(); // Serialie the cache\n\n    // Parsing and validation steps here . . .\n\n    // key (authority-user) - value (serialized session)\n    await redis.set(cacheKey(tenantKey), serialized);\n  },\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Benefits:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Security"}),": Refresh tokens never leave Redis."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simplicity"}),": MSAL automatically handles silent refresh using cached RTs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Speed"}),": Redis read/write operations are extremely fast, even under load."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session management"}),": All user sessions are centralized, visible in ",(0,t.jsx)(n.strong,{children:"RedisInsight UI"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"3-smarter-refresh-strategy",children:"3. Smarter Refresh Strategy"}),"\n",(0,t.jsxs)(n.p,{children:["Instead of refreshing tokens on every request, I only refresh ",(0,t.jsx)(n.strong,{children:"when the access token is expired"}),", using the RT as a buffer.",(0,t.jsx)(n.br,{}),"\n","This reduces unnecessary calls and provides a natural logout mechanism when RTs are gone."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'if (jwt && isTokenExpiring(jwt, 0)) {\n  const result = await refreshAccessToken(\n    session.get("tenantId") as string,\n    account.homeAccountId,\n    [`${session.get("audience")}/User.Read`]\n  );\n  if (result?.accessToken) {\n    session.set("jwtToken", result.accessToken);\n  }\n\n\nexport const refreshAccessToken = async (...): Promise<msal.AuthenticationResult | null> => {\n    const cca = getCCA(tenantKey); // Uses the singleton factory instance for the given tenant\n    const cache = cca.getTokenCache();\n\n    // Force hydration from Redis (using specific tenant key)\n    const snapshot = await redis.get(`msal-cache:${tenantKey}`);\n    if (snapshot) {\n        cache.deserialize(snapshot);\n    }\n\n    // Parsing logic ...\n\n    return await cca.acquireTokenSilent({ account, scopes });\n\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"4-redisinsight-for-session-management--ops",children:"4. RedisInsight for Session Management & Ops"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"alt text",src:s(7109).A+"",width:"1908",height:"953"})}),"\n",(0,t.jsxs)(n.p,{children:["Beyond just caching, ",(0,t.jsx)(n.strong,{children:"RedisInsight"})," provides real-time operational visibility into MSAL sessions.",(0,t.jsx)(n.br,{}),"\n","Every tenant\u2019s token cache entry (",(0,t.jsx)(n.code,{children:"msal-cache:<tenantId>"}),") can be inspected directly, allowing ",(0,t.jsx)(n.strong,{children:"debugging, testing, and operations teams"})," to monitor user session activity."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Operational Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transparency"})," \u2014 Inspect active sessions, access tokens, and refresh tokens in real time."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Debugging"})," \u2014 Identify issues with token expiration, authority mismatches, or tenant misconfigurations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitoring"})," \u2014 Track session load, token churn, and Redis key usage across all tenants."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Security auditing"})," \u2014 Validate refresh tokens remain isolated per-tenant and ensure session cleanup works as expected."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This means the ",(0,t.jsx)(n.strong,{children:"Ops team no longer flies blind"})," \u2014 RedisInsight provides a clear window into live authentication state across the distributed container environment."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-results",children:"\ud83c\udfc6 Results"}),"\n",(0,t.jsxs)(n.admonition,{title:"Operational Gain",type:"tip",children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"With Redis + MSAL:"})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Secure token lifecycle"}),"\n",(0,t.jsx)(n.li,{children:"Stable user sessions across container replicas"}),"\n",(0,t.jsx)(n.li,{children:"Real-time session visibility in RedisInsight"}),"\n",(0,t.jsx)(n.li,{children:"Faster, simpler, and safer than in-memory caching"}),"\n"]})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Security"}),": Tokens isolated per tenant; refresh tokens stored only in Redis."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simplicity"}),": Centralized session logic removes complexity from app code."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Speed"}),": Sub-millisecond Redis access accelerates silent refresh."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session Management"}),": RedisInsight UI lets ops/debug teams inspect active sessions directly."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-key-takeaways",children:"\ud83d\udcda Key Takeaways"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Build on Entra with MSAL, don\u2019t re-invent OAuth."}),(0,t.jsx)(n.br,{}),"\n","The ",(0,t.jsx)(n.strong,{children:"OIDC flows are handled by MSAL"}),", freeing us to focus on higher-level session logic."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Redis is the best fit"}),": secure, simple, fast, and observable."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Backend-for-Frontend (BFF) pattern"}),":",(0,t.jsx)(n.br,{}),"\n","This cache-backed authentication service acts as a ",(0,t.jsx)(n.strong,{children:"BFF for identity"})," \u2014 decoupling both the ",(0,t.jsx)(n.strong,{children:"frontend"})," and the ",(0,t.jsx)(n.strong,{children:"downstream APIs"})," from the complexity of Entra, tokens, and multi-tenant login."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.strong,{children:"frontend"})," simply consumes a stable session, without needing to know about certificates, refresh tokens, or tenant switching."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.strong,{children:"data APIs"})," no longer have to implement or understand MSAL or Entra authentication \u2014 they only receive validated, context-rich tokens or session claims from the BFF."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This separation allows APIs to stay ",(0,t.jsx)(n.strong,{children:"focused on business logic"}),", while the BFF centralizes identity, session management, and security enforcement."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimize once, reuse everywhere."}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Token caching and session persistence"})," should live in a ",(0,t.jsx)(n.strong,{children:"shared cache layer"}),", not in every container instance."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.admonition,{title:"Other Contributors",type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minh Phan"})," \u2014 Set up certificate service, and reccomended not to use innactivity logouts. And helped establish original MSAL-Node."]}),"\n"]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var i=s(6540);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);