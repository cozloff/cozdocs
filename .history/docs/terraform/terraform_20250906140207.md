---
sidebar_position: 7
---

# Terraform + Azure ‚Äî Full Infrastructure Automation

![alt text](image-1.png)

This paper highlights the **standardized Terraform modules and terraform state** and **automated provisioning of our entire application and global infrastructure**, signifying the start of **complete deployment automation from the hardware up ‚Üí SUCCESS!**

It also demonstrates why **Terraform should be an organizational microservice for infrastructure provisioning**, not just scattered scripts or manual portal clicks.

---

## üö© Challenge

Terraform is powerful, but **raw, unstructured configs are not enough** for enterprise-scale infrastructure:

- **State management issues**: Without remote state, multiple users drifted into inconsistent infra states.
- **Duplication & inefficiency**: Hardcoded resources repeated across teams and projects.
- **Operational overhead**: Manual provisioning in the Azure Portal slowed down deployment velocity.
- **Disagreement on scope**: EISB recommended Terraform _only_ for infrastructure resources, not administrative resources in Entra ‚Äî but full automation requires both.

**Solution:** build a **modular Terraform system** with remote state, service segmentation, and reusable patterns that automate provisioning from the ground up.

---

## ‚ö° Solution

Week 8/30/2025, I introduced several improvements:

### 1. Standardized Terraform Modules

![alt text](image-3.png)

Organized the Terraform code into **modules per resource type** (e.g., Managed Identities, Resource groups, Key Vault, MongoDB, Redis, Container Apps).  
This gave us a **clean abstraction layer** and allows references across environments, without having to provide all the implementation details in the main file.

```hcl
# Ex. MongoDB Cluster
module "mongo_cluster" {
    source              = "./modules/mongo_cluster"
    resource_group_name = module.resource_group.resource_group_name
    location            = module.resource_group.location
    mongodb_username    = var.mongodb_username
    mongodb_password    = var.mongodb_password
    tag                 = var.tag
}
```

Used Loops and Conditionals only made possible by IaC:

```hcl
  # Ex. App Roles
  dynamic "app_role" {
    for_each = var.roles
    content {
      id                   = random_uuid.role_ids[app_role.key].result
      value                = app_role.value
      display_name         = title(app_role.key)
      description          = "${title(app_role.key)} role"
      allowed_member_types = ["User"]
      enabled              = true
    }
  }
```

---

### 2. Remote State in Blob Storage

![alt text](image-5.png)

Provisioned **Azure Blob Storage** to host Terraform state for every major component.  
This guarantees all engineers share the **same tfstate** and prevents conflicts during apply/destroy operations.

```hcl
terraform {
  backend "azurerm" {
    resource_group_name   = [Classified]
    storage_account_name  = [Classified]
    container_name        = [Classified]
    key                   = "terraform.tfstate"
  }
}
```

Created **separate blobs** for key stacks, provisioned from a centralized **terraform state blob hub**.

- Terraform State Hub
- Azure Container Registry
- Operations Stack
  1. Container Apps Environment
  2. Loki Infrastructure
  3. Grafana Infrastructure
- HSR Infrastructure (Container Apps, Mongo, Key Vault, Entra, Redis, etc.)

Referencing global infrastructure using data blocks:

```hcl
#Ex. Global container apps environment
data "azurerm_container_app_environment" "aca_env" {
  name                = [Classified]
  resource_group_name = [Classified]
}
```

---

### 3. Provisioned Entire Infrastructure with High Velocity:

---

### 9/6/2025 This Week:

**Flow executed successfully:**

1. ‚úÖ Review Code
2. ‚úÖ Provision tfstate blobs
3. ‚úÖ Provision ACR
4. ‚úÖ Provision Operations Stack
5. ‚úÖ Provision HSR
6. ‚úÖ Destroy it all
7. ‚úÖ Rebuild it all again

This demonstrates **end-to-end automation**: from initial infra creation to safe teardown, without manual portal interaction.

---

## üèÜ Results

:::tip Deployment Gain
**Never again do you have to click through the Azure Portal to:**

- Register apps in Entra
- Spin up container apps or resource groups
- Manually delete resources in order

All of this is automated, reusable, and idempotent.
:::

- **Consistency**: Remote state ensures every engineer works from the same source of truth.
- **Scalability**: Global services (Kubernetes, Kafka, ACA env) can be referenced by app stacks.
- **Velocity**: New environments can be provisioned in minutes, not days.
- **Revolutionary UX**: Infrastructure provisioning is now self-service, reusable, and future-proof.

---

## üìö Key Takeaways

**Build on Terraform, don‚Äôt just call Azure manually.**  
The **Azure Portal** is powerful but **manual** ‚Äî organizations need **IaC microservices** to make infra consumable at scale.

**Terraform + Azure Blob remote state is the best fit**: **modular**, **team-safe**, and deeply integrated with cloud-native workflows.

**Optimize once, reuse everywhere.**  
**Infrastructure automation** should live in a **shared service**, not in every engineer‚Äôs local scripts.

---

:::info Other Contributors

- **Minh Phan** ‚Äî Standardized resource naming conventions, as well as partnered in architecting our cloud infrastructure.
- **Kelly Lee & Cliff Goto** ‚Äî Alignment on Terraform usage for infra vs administrative resources  
  :::
