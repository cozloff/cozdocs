---
sidebar_position: 7
---

# Terraform + Azure ‚Äî Full Infrastructure Automation

![alt text](image-1.png)

This paper highlights how we **standardized Terraform code into modules** and **automated provisioning of our entire application and global infrastructure**, signifying the start of **complete deployment automation from the hardware up ‚Üí SUCCESS!**

It also demonstrates why **Terraform should be an organizational microservice for infrastructure provisioning**, not just scattered scripts or manual portal clicks.

---

## üö© Challenge

Terraform is powerful, but **raw, unstructured configs are not enough** for enterprise-scale infrastructure:

- **State management issues**: Without remote state, multiple users drifted into inconsistent infra states.
- **Duplication & inefficiency**: Hardcoded resources repeated across teams and projects.
- **Operational overhead**: Manual provisioning in the Azure Portal slowed down deployment velocity.
- **Disagreement on scope**: EISB recommended Terraform _only_ for infrastructure resources, not administrative resources in Entra ‚Äî but full automation requires both.

**Solution:** build a **modular Terraform system** with remote state, service segmentation, and reusable patterns that automate provisioning from the ground up.

---

## ‚ö° Solution

Week 9/6/2025, I introduced several improvements:

### 1. Standardized Terraform Modules

Organized the Terraform code into **modules per resource type** (e.g., resource groups, Key Vault, MongoDB, Redis, Container Apps).  
This gave us a **clean abstraction layer** and reduced repetition across environments.

```hcl
# Example: Resource Group module
module "resource_group" {
  source              = "./modules/resource_group"
  resource_group_name = "rg-hsr-qa-808"
  location            = "westus2"
  tag                 = var.tag
}
```

---

### 2. Remote State in Blob Storage

Provisioned **Azure Blob Storage** to host Terraform state for every major component.  
This guarantees all engineers share the **same tfstate** and prevents conflicts during apply/destroy operations.

```hcl
terraform {
  backend "azurerm" {
    resource_group_name   = "rg-global-001"
    storage_account_name  = "stglobal808"
    container_name        = "hsr-tfstate"
    key                   = "terraform.tfstate"
  }
}
```

We created **separate containers** for key stacks (`acr-tfstate`, `operations-tfstate`, `hsr-tfstate`) and global resources (Kubernetes, Kafka).

---

### 3. Provisioning Critical Services

Automated deployment of:

- **Azure Container Registry (ACR)**
- **Operations Stack** ‚Üí with Loki + Grafana container apps, analytics workspace, and log pipeline
- **HSR Stack** ‚Üí resource groups, Key Vault, MongoDB cluster, Redis Cache, container apps
- **Global Environment** ‚Üí shared container app environment, global state references

```hcl
resource "azurerm_container_app" "grafana_app" {
  name                         = "operations-grafana-container"
  container_app_environment_id = azurerm_container_app_environment.app_environment.id
  resource_group_name          = var.resource_group_name
  revision_mode                = "Multiple"
  template {
    container {
      name   = "operations-grafana-container"
      image  = "mcr.microsoft.com/azuredocs/containerapps-helloworld:latest"
      cpu    = 0.25
      memory = "0.5Gi"
    }
  }
  ingress {
    target_port     = 80
    external_enabled = false
  }
}
```

---

### 4. Full Lifecycle Automation

**Flow executed successfully:**

1. ‚úÖ Review Code
2. ‚úÖ Provision tfstate blobs
3. ‚úÖ Provision ACR
4. ‚úÖ Provision Operations Stack
5. ‚úÖ Provision HSR
6. ‚úÖ Destroy it all

This demonstrates **end-to-end automation**: from initial infra creation to safe teardown, without manual portal interaction.

---

## üèÜ Results

:::tip Deployment Gain
**Never again do you have to click through the Azure Portal to:**

- Register apps in Entra
- Spin up container apps or resource groups
- Manually delete resources in order

All of this is automated, reusable, and idempotent.
:::

- **Consistency**: Remote state ensures every engineer works from the same source of truth.
- **Scalability**: Global services (Kubernetes, Kafka, ACA env) can be referenced by app stacks.
- **Velocity**: New environments can be provisioned in minutes, not days.
- **Revolutionary UX**: Infrastructure provisioning is now self-service, reusable, and future-proof.

---

## üìö Key Takeaways

**Build on Terraform, don‚Äôt just call Azure manually.**  
The **Azure Portal** is powerful but **manual** ‚Äî organizations need **IaC microservices** to make infra consumable at scale.

**Terraform + Azure Blob remote state is the best fit**: **modular**, **team-safe**, and deeply integrated with cloud-native workflows.

**Optimize once, reuse everywhere.**  
**Infrastructure automation** should live in a **shared service**, not in every engineer‚Äôs local scripts.

---

:::info Other Contributors

- **Minh Phan** ‚Äî Standardized resource naming conventions, as well as partnered in architecting our cloud infrastructure.
- **Kelly Lee & Cliff Goto** ‚Äî Alignment on Terraform usage for infra vs administrative resources  
  :::
