---
sidebar_position: 7
---

# Terraform

![alt text](image.png)

This paper highlights how to significantly improve **Entra Graph API performance** by introducing an application layer built in **ASP.NET (C#)**, enabling **efficient automation of identity administration**.

It also demonstrates why **Entra automation belongs in a dedicated organizational microservice**, not scattered across scripts or siloed apps.

---

## üö© Challenge

Microsoft Entra provides the identity backbone, but **raw Graph API calls are not enough** for enterprise-scale automation:

- **Redundancy & inefficiency**: Direct Graph calls often repeat the same expensive queries.
- **Complex throttling rules**: API limits (e.g. 15 users per bulk request) make na√Øve implementations brittle.
- **Concurrency pitfalls**: Scripts or lightweight tools often break under multi-threaded workloads.
- **Policy enforcement**: Without a central layer, authorization logic is duplicated inconsistently across teams.

**Solution:** build a reusable **application service** on top of Entra that abstracts these complexities, optimizes Graph access, and standardizes identity automation for the whole organization.

---

## ‚ö° Solution

I introduced three main improvements:

### 1. Hash Map for User ‚Üî Role

Instead of fetching user objects repeatedly for each role group, I **parallelized group membership fetching** but stored results in a **dictionary** mapping `UserId ‚Üí Role`.

```cs
// Build dictionary UserId ‚Üí Role (single role only)
Dictionary<string, string> roleMap = userRoles
    .GroupBy(m => m.UserId)
    .ToDictionary(
        g => g.Key,
        g => g.First().Role
    );
```

---

### 2. Batch Processing to Avoid Throttling

The Graph API has a **hard 15-user batch limit**. To handle this, I processed user IDs in **chunks of 15**, calling the bulk endpoint only once per batch.

```csharp
// Process in batches of 15
for (int i = 0; i < userIds.Count; i += 15)
{
    List<string> batch = userIds.Skip(i).Take(15).ToList();

    // Bulk fetch all users by IDs
    string ids = string.Join(",", batch.Select(id => $"'{id}'"));
    Result<UserCollectionResponse> usersResponse =
        await _graphRepository.GetAllUsersInfo15Max(ids);

    // ...
}
```

---

### 3. Safe Parallelization + Race Condition Fix

Users are projected **in parallel** while avoiding shared state mutation. Instead of threads colliding, each batch aggregates safely, and results are flattened only after completion:

```csharp
IEnumerable<Task<UserInfo>> tasks = usersResponse.Value.Value.Select(
    async user =>
    {
        string role = roleMap.ContainsKey(user.Id) ? roleMap[user.Id] : string.Empty;
        string roleValue = MapRole(role);

        return new UserInfo
        {
            ...
            Role = roleValue
        };
    });

UserInfo[] results = await Task.WhenAll(tasks);
allUsers.AddRange(results);
```

---

## üèÜ Results

:::tip Performance Gain
**10 seconds for 5 users ‚Üí a few milliseconds for 20 users.**
:::

- **Stable concurrency**: Race condition eliminated when parallelizing.
- **Resilient against throttling**: Clean batch processing aligned with Graph‚Äôs 15-user cap.
- **Reusability**: Teams can now consume this identity microservice instead of re-implementing Graph logic.

---

## üìö Key Takeaways

**Build on Entra, don‚Äôt just call it.**  
The **Graph API** is powerful but **low-level** ‚Äî organizations need an **application layer microservice** to make it **consumable at scale**.

**.NET is the best fit** for this layer: **type-safe**, **async-friendly**, and deeply integrated with **Microsoft identity**.

**Optimize once, reuse everywhere.**  
**Identity automation** should live in a **shared service**, not inside every app.

---

:::info Other Contributors

- **Minh Phan** ‚Äî Parallelization strategy & for key contributions to utilizing Entra for workforce and external users
- **Kupu Tuifua** ‚Äî Typing & repository refactoring
- **Ian Manzano** ‚Äî End-to-end testing the graph services
  :::
